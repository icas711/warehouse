// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'warehouse_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$WarehouseEvent {
  int get page => throw _privateConstructorUsedError;
  int get pageSize => throw _privateConstructorUsedError;
  String get itemName => throw _privateConstructorUsedError;
  String get sortBy => throw _privateConstructorUsedError;
  String get sortOrder => throw _privateConstructorUsedError;
  String get token => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int page, int pageSize, String itemName,
            String sortBy, String sortOrder, String token)
        fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int page, int pageSize, String itemName, String sortBy,
            String sortOrder, String token)?
        fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int page, int pageSize, String itemName, String sortBy,
            String sortOrder, String token)?
        fetch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarehouseEventFetch value) fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarehouseEventFetch value)? fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarehouseEventFetch value)? fetch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WarehouseEventCopyWith<WarehouseEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarehouseEventCopyWith<$Res> {
  factory $WarehouseEventCopyWith(
          WarehouseEvent value, $Res Function(WarehouseEvent) then) =
      _$WarehouseEventCopyWithImpl<$Res, WarehouseEvent>;
  @useResult
  $Res call(
      {int page,
      int pageSize,
      String itemName,
      String sortBy,
      String sortOrder,
      String token});
}

/// @nodoc
class _$WarehouseEventCopyWithImpl<$Res, $Val extends WarehouseEvent>
    implements $WarehouseEventCopyWith<$Res> {
  _$WarehouseEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? page = null,
    Object? pageSize = null,
    Object? itemName = null,
    Object? sortBy = null,
    Object? sortOrder = null,
    Object? token = null,
  }) {
    return _then(_value.copyWith(
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      pageSize: null == pageSize
          ? _value.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int,
      itemName: null == itemName
          ? _value.itemName
          : itemName // ignore: cast_nullable_to_non_nullable
              as String,
      sortBy: null == sortBy
          ? _value.sortBy
          : sortBy // ignore: cast_nullable_to_non_nullable
              as String,
      sortOrder: null == sortOrder
          ? _value.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WarehouseEventFetchImplCopyWith<$Res>
    implements $WarehouseEventCopyWith<$Res> {
  factory _$$WarehouseEventFetchImplCopyWith(_$WarehouseEventFetchImpl value,
          $Res Function(_$WarehouseEventFetchImpl) then) =
      __$$WarehouseEventFetchImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int page,
      int pageSize,
      String itemName,
      String sortBy,
      String sortOrder,
      String token});
}

/// @nodoc
class __$$WarehouseEventFetchImplCopyWithImpl<$Res>
    extends _$WarehouseEventCopyWithImpl<$Res, _$WarehouseEventFetchImpl>
    implements _$$WarehouseEventFetchImplCopyWith<$Res> {
  __$$WarehouseEventFetchImplCopyWithImpl(_$WarehouseEventFetchImpl _value,
      $Res Function(_$WarehouseEventFetchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? page = null,
    Object? pageSize = null,
    Object? itemName = null,
    Object? sortBy = null,
    Object? sortOrder = null,
    Object? token = null,
  }) {
    return _then(_$WarehouseEventFetchImpl(
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      pageSize: null == pageSize
          ? _value.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int,
      itemName: null == itemName
          ? _value.itemName
          : itemName // ignore: cast_nullable_to_non_nullable
              as String,
      sortBy: null == sortBy
          ? _value.sortBy
          : sortBy // ignore: cast_nullable_to_non_nullable
              as String,
      sortOrder: null == sortOrder
          ? _value.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WarehouseEventFetchImpl implements WarehouseEventFetch {
  _$WarehouseEventFetchImpl(
      {required this.page,
      required this.pageSize,
      required this.itemName,
      required this.sortBy,
      required this.sortOrder,
      required this.token});

  @override
  final int page;
  @override
  final int pageSize;
  @override
  final String itemName;
  @override
  final String sortBy;
  @override
  final String sortOrder;
  @override
  final String token;

  @override
  String toString() {
    return 'WarehouseEvent.fetch(page: $page, pageSize: $pageSize, itemName: $itemName, sortBy: $sortBy, sortOrder: $sortOrder, token: $token)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarehouseEventFetchImpl &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.itemName, itemName) ||
                other.itemName == itemName) &&
            (identical(other.sortBy, sortBy) || other.sortBy == sortBy) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder) &&
            (identical(other.token, token) || other.token == token));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, page, pageSize, itemName, sortBy, sortOrder, token);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WarehouseEventFetchImplCopyWith<_$WarehouseEventFetchImpl> get copyWith =>
      __$$WarehouseEventFetchImplCopyWithImpl<_$WarehouseEventFetchImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int page, int pageSize, String itemName,
            String sortBy, String sortOrder, String token)
        fetch,
  }) {
    return fetch(page, pageSize, itemName, sortBy, sortOrder, token);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int page, int pageSize, String itemName, String sortBy,
            String sortOrder, String token)?
        fetch,
  }) {
    return fetch?.call(page, pageSize, itemName, sortBy, sortOrder, token);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int page, int pageSize, String itemName, String sortBy,
            String sortOrder, String token)?
        fetch,
    required TResult orElse(),
  }) {
    if (fetch != null) {
      return fetch(page, pageSize, itemName, sortBy, sortOrder, token);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarehouseEventFetch value) fetch,
  }) {
    return fetch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarehouseEventFetch value)? fetch,
  }) {
    return fetch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarehouseEventFetch value)? fetch,
    required TResult orElse(),
  }) {
    if (fetch != null) {
      return fetch(this);
    }
    return orElse();
  }
}

abstract class WarehouseEventFetch implements WarehouseEvent {
  factory WarehouseEventFetch(
      {required final int page,
      required final int pageSize,
      required final String itemName,
      required final String sortBy,
      required final String sortOrder,
      required final String token}) = _$WarehouseEventFetchImpl;

  @override
  int get page;
  @override
  int get pageSize;
  @override
  String get itemName;
  @override
  String get sortBy;
  @override
  String get sortOrder;
  @override
  String get token;
  @override
  @JsonKey(ignore: true)
  _$$WarehouseEventFetchImplCopyWith<_$WarehouseEventFetchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EditEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(Item item) start,
    required TResult Function() add,
    required TResult Function(String name, String measurement_units,
            String code, String description, String token)
        addFetch,
    required TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)
        fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(Item item)? start,
    TResult? Function()? add,
    TResult? Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult? Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(Item item)? start,
    TResult Function()? add,
    TResult Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditEventIdle value) idle,
    required TResult Function(EditEventStart value) start,
    required TResult Function(EditEventAdd value) add,
    required TResult Function(AddEventFetch value) addFetch,
    required TResult Function(EditEventFetch value) fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditEventIdle value)? idle,
    TResult? Function(EditEventStart value)? start,
    TResult? Function(EditEventAdd value)? add,
    TResult? Function(AddEventFetch value)? addFetch,
    TResult? Function(EditEventFetch value)? fetch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditEventIdle value)? idle,
    TResult Function(EditEventStart value)? start,
    TResult Function(EditEventAdd value)? add,
    TResult Function(AddEventFetch value)? addFetch,
    TResult Function(EditEventFetch value)? fetch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditEventCopyWith<$Res> {
  factory $EditEventCopyWith(EditEvent value, $Res Function(EditEvent) then) =
      _$EditEventCopyWithImpl<$Res, EditEvent>;
}

/// @nodoc
class _$EditEventCopyWithImpl<$Res, $Val extends EditEvent>
    implements $EditEventCopyWith<$Res> {
  _$EditEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EditEventIdleImplCopyWith<$Res> {
  factory _$$EditEventIdleImplCopyWith(
          _$EditEventIdleImpl value, $Res Function(_$EditEventIdleImpl) then) =
      __$$EditEventIdleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EditEventIdleImplCopyWithImpl<$Res>
    extends _$EditEventCopyWithImpl<$Res, _$EditEventIdleImpl>
    implements _$$EditEventIdleImplCopyWith<$Res> {
  __$$EditEventIdleImplCopyWithImpl(
      _$EditEventIdleImpl _value, $Res Function(_$EditEventIdleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EditEventIdleImpl implements EditEventIdle {
  _$EditEventIdleImpl();

  @override
  String toString() {
    return 'EditEvent.idle()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditEventIdleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(Item item) start,
    required TResult Function() add,
    required TResult Function(String name, String measurement_units,
            String code, String description, String token)
        addFetch,
    required TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)
        fetch,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(Item item)? start,
    TResult? Function()? add,
    TResult? Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult? Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(Item item)? start,
    TResult Function()? add,
    TResult Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditEventIdle value) idle,
    required TResult Function(EditEventStart value) start,
    required TResult Function(EditEventAdd value) add,
    required TResult Function(AddEventFetch value) addFetch,
    required TResult Function(EditEventFetch value) fetch,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditEventIdle value)? idle,
    TResult? Function(EditEventStart value)? start,
    TResult? Function(EditEventAdd value)? add,
    TResult? Function(AddEventFetch value)? addFetch,
    TResult? Function(EditEventFetch value)? fetch,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditEventIdle value)? idle,
    TResult Function(EditEventStart value)? start,
    TResult Function(EditEventAdd value)? add,
    TResult Function(AddEventFetch value)? addFetch,
    TResult Function(EditEventFetch value)? fetch,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class EditEventIdle implements EditEvent {
  factory EditEventIdle() = _$EditEventIdleImpl;
}

/// @nodoc
abstract class _$$EditEventStartImplCopyWith<$Res> {
  factory _$$EditEventStartImplCopyWith(_$EditEventStartImpl value,
          $Res Function(_$EditEventStartImpl) then) =
      __$$EditEventStartImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Item item});

  $ItemCopyWith<$Res> get item;
}

/// @nodoc
class __$$EditEventStartImplCopyWithImpl<$Res>
    extends _$EditEventCopyWithImpl<$Res, _$EditEventStartImpl>
    implements _$$EditEventStartImplCopyWith<$Res> {
  __$$EditEventStartImplCopyWithImpl(
      _$EditEventStartImpl _value, $Res Function(_$EditEventStartImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
  }) {
    return _then(_$EditEventStartImpl(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as Item,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ItemCopyWith<$Res> get item {
    return $ItemCopyWith<$Res>(_value.item, (value) {
      return _then(_value.copyWith(item: value));
    });
  }
}

/// @nodoc

class _$EditEventStartImpl implements EditEventStart {
  _$EditEventStartImpl({required this.item});

  @override
  final Item item;

  @override
  String toString() {
    return 'EditEvent.start(item: $item)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditEventStartImpl &&
            (identical(other.item, item) || other.item == item));
  }

  @override
  int get hashCode => Object.hash(runtimeType, item);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EditEventStartImplCopyWith<_$EditEventStartImpl> get copyWith =>
      __$$EditEventStartImplCopyWithImpl<_$EditEventStartImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(Item item) start,
    required TResult Function() add,
    required TResult Function(String name, String measurement_units,
            String code, String description, String token)
        addFetch,
    required TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)
        fetch,
  }) {
    return start(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(Item item)? start,
    TResult? Function()? add,
    TResult? Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult? Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
  }) {
    return start?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(Item item)? start,
    TResult Function()? add,
    TResult Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditEventIdle value) idle,
    required TResult Function(EditEventStart value) start,
    required TResult Function(EditEventAdd value) add,
    required TResult Function(AddEventFetch value) addFetch,
    required TResult Function(EditEventFetch value) fetch,
  }) {
    return start(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditEventIdle value)? idle,
    TResult? Function(EditEventStart value)? start,
    TResult? Function(EditEventAdd value)? add,
    TResult? Function(AddEventFetch value)? addFetch,
    TResult? Function(EditEventFetch value)? fetch,
  }) {
    return start?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditEventIdle value)? idle,
    TResult Function(EditEventStart value)? start,
    TResult Function(EditEventAdd value)? add,
    TResult Function(AddEventFetch value)? addFetch,
    TResult Function(EditEventFetch value)? fetch,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(this);
    }
    return orElse();
  }
}

abstract class EditEventStart implements EditEvent {
  factory EditEventStart({required final Item item}) = _$EditEventStartImpl;

  Item get item;
  @JsonKey(ignore: true)
  _$$EditEventStartImplCopyWith<_$EditEventStartImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditEventAddImplCopyWith<$Res> {
  factory _$$EditEventAddImplCopyWith(
          _$EditEventAddImpl value, $Res Function(_$EditEventAddImpl) then) =
      __$$EditEventAddImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EditEventAddImplCopyWithImpl<$Res>
    extends _$EditEventCopyWithImpl<$Res, _$EditEventAddImpl>
    implements _$$EditEventAddImplCopyWith<$Res> {
  __$$EditEventAddImplCopyWithImpl(
      _$EditEventAddImpl _value, $Res Function(_$EditEventAddImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EditEventAddImpl implements EditEventAdd {
  _$EditEventAddImpl();

  @override
  String toString() {
    return 'EditEvent.add()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditEventAddImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(Item item) start,
    required TResult Function() add,
    required TResult Function(String name, String measurement_units,
            String code, String description, String token)
        addFetch,
    required TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)
        fetch,
  }) {
    return add();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(Item item)? start,
    TResult? Function()? add,
    TResult? Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult? Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
  }) {
    return add?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(Item item)? start,
    TResult Function()? add,
    TResult Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditEventIdle value) idle,
    required TResult Function(EditEventStart value) start,
    required TResult Function(EditEventAdd value) add,
    required TResult Function(AddEventFetch value) addFetch,
    required TResult Function(EditEventFetch value) fetch,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditEventIdle value)? idle,
    TResult? Function(EditEventStart value)? start,
    TResult? Function(EditEventAdd value)? add,
    TResult? Function(AddEventFetch value)? addFetch,
    TResult? Function(EditEventFetch value)? fetch,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditEventIdle value)? idle,
    TResult Function(EditEventStart value)? start,
    TResult Function(EditEventAdd value)? add,
    TResult Function(AddEventFetch value)? addFetch,
    TResult Function(EditEventFetch value)? fetch,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class EditEventAdd implements EditEvent {
  factory EditEventAdd() = _$EditEventAddImpl;
}

/// @nodoc
abstract class _$$AddEventFetchImplCopyWith<$Res> {
  factory _$$AddEventFetchImplCopyWith(
          _$AddEventFetchImpl value, $Res Function(_$AddEventFetchImpl) then) =
      __$$AddEventFetchImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String name,
      String measurement_units,
      String code,
      String description,
      String token});
}

/// @nodoc
class __$$AddEventFetchImplCopyWithImpl<$Res>
    extends _$EditEventCopyWithImpl<$Res, _$AddEventFetchImpl>
    implements _$$AddEventFetchImplCopyWith<$Res> {
  __$$AddEventFetchImplCopyWithImpl(
      _$AddEventFetchImpl _value, $Res Function(_$AddEventFetchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? measurement_units = null,
    Object? code = null,
    Object? description = null,
    Object? token = null,
  }) {
    return _then(_$AddEventFetchImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      measurement_units: null == measurement_units
          ? _value.measurement_units
          : measurement_units // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AddEventFetchImpl implements AddEventFetch {
  _$AddEventFetchImpl(
      {required this.name,
      required this.measurement_units,
      required this.code,
      required this.description,
      required this.token});

  @override
  final String name;
  @override
  final String measurement_units;
  @override
  final String code;
  @override
  final String description;
  @override
  final String token;

  @override
  String toString() {
    return 'EditEvent.addFetch(name: $name, measurement_units: $measurement_units, code: $code, description: $description, token: $token)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddEventFetchImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.measurement_units, measurement_units) ||
                other.measurement_units == measurement_units) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.token, token) || other.token == token));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, name, measurement_units, code, description, token);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddEventFetchImplCopyWith<_$AddEventFetchImpl> get copyWith =>
      __$$AddEventFetchImplCopyWithImpl<_$AddEventFetchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(Item item) start,
    required TResult Function() add,
    required TResult Function(String name, String measurement_units,
            String code, String description, String token)
        addFetch,
    required TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)
        fetch,
  }) {
    return addFetch(name, measurement_units, code, description, token);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(Item item)? start,
    TResult? Function()? add,
    TResult? Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult? Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
  }) {
    return addFetch?.call(name, measurement_units, code, description, token);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(Item item)? start,
    TResult Function()? add,
    TResult Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
    required TResult orElse(),
  }) {
    if (addFetch != null) {
      return addFetch(name, measurement_units, code, description, token);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditEventIdle value) idle,
    required TResult Function(EditEventStart value) start,
    required TResult Function(EditEventAdd value) add,
    required TResult Function(AddEventFetch value) addFetch,
    required TResult Function(EditEventFetch value) fetch,
  }) {
    return addFetch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditEventIdle value)? idle,
    TResult? Function(EditEventStart value)? start,
    TResult? Function(EditEventAdd value)? add,
    TResult? Function(AddEventFetch value)? addFetch,
    TResult? Function(EditEventFetch value)? fetch,
  }) {
    return addFetch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditEventIdle value)? idle,
    TResult Function(EditEventStart value)? start,
    TResult Function(EditEventAdd value)? add,
    TResult Function(AddEventFetch value)? addFetch,
    TResult Function(EditEventFetch value)? fetch,
    required TResult orElse(),
  }) {
    if (addFetch != null) {
      return addFetch(this);
    }
    return orElse();
  }
}

abstract class AddEventFetch implements EditEvent {
  factory AddEventFetch(
      {required final String name,
      required final String measurement_units,
      required final String code,
      required final String description,
      required final String token}) = _$AddEventFetchImpl;

  String get name;
  String get measurement_units;
  String get code;
  String get description;
  String get token;
  @JsonKey(ignore: true)
  _$$AddEventFetchImplCopyWith<_$AddEventFetchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditEventFetchImplCopyWith<$Res> {
  factory _$$EditEventFetchImplCopyWith(_$EditEventFetchImpl value,
          $Res Function(_$EditEventFetchImpl) then) =
      __$$EditEventFetchImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String id,
      String name,
      String measurement_units,
      String code,
      String description,
      String token});
}

/// @nodoc
class __$$EditEventFetchImplCopyWithImpl<$Res>
    extends _$EditEventCopyWithImpl<$Res, _$EditEventFetchImpl>
    implements _$$EditEventFetchImplCopyWith<$Res> {
  __$$EditEventFetchImplCopyWithImpl(
      _$EditEventFetchImpl _value, $Res Function(_$EditEventFetchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? measurement_units = null,
    Object? code = null,
    Object? description = null,
    Object? token = null,
  }) {
    return _then(_$EditEventFetchImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      measurement_units: null == measurement_units
          ? _value.measurement_units
          : measurement_units // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EditEventFetchImpl implements EditEventFetch {
  _$EditEventFetchImpl(
      {required this.id,
      required this.name,
      required this.measurement_units,
      required this.code,
      required this.description,
      required this.token});

  @override
  final String id;
  @override
  final String name;
  @override
  final String measurement_units;
  @override
  final String code;
  @override
  final String description;
  @override
  final String token;

  @override
  String toString() {
    return 'EditEvent.fetch(id: $id, name: $name, measurement_units: $measurement_units, code: $code, description: $description, token: $token)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditEventFetchImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.measurement_units, measurement_units) ||
                other.measurement_units == measurement_units) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.token, token) || other.token == token));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, id, name, measurement_units, code, description, token);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EditEventFetchImplCopyWith<_$EditEventFetchImpl> get copyWith =>
      __$$EditEventFetchImplCopyWithImpl<_$EditEventFetchImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(Item item) start,
    required TResult Function() add,
    required TResult Function(String name, String measurement_units,
            String code, String description, String token)
        addFetch,
    required TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)
        fetch,
  }) {
    return fetch(id, name, measurement_units, code, description, token);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(Item item)? start,
    TResult? Function()? add,
    TResult? Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult? Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
  }) {
    return fetch?.call(id, name, measurement_units, code, description, token);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(Item item)? start,
    TResult Function()? add,
    TResult Function(String name, String measurement_units, String code,
            String description, String token)?
        addFetch,
    TResult Function(String id, String name, String measurement_units,
            String code, String description, String token)?
        fetch,
    required TResult orElse(),
  }) {
    if (fetch != null) {
      return fetch(id, name, measurement_units, code, description, token);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditEventIdle value) idle,
    required TResult Function(EditEventStart value) start,
    required TResult Function(EditEventAdd value) add,
    required TResult Function(AddEventFetch value) addFetch,
    required TResult Function(EditEventFetch value) fetch,
  }) {
    return fetch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditEventIdle value)? idle,
    TResult? Function(EditEventStart value)? start,
    TResult? Function(EditEventAdd value)? add,
    TResult? Function(AddEventFetch value)? addFetch,
    TResult? Function(EditEventFetch value)? fetch,
  }) {
    return fetch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditEventIdle value)? idle,
    TResult Function(EditEventStart value)? start,
    TResult Function(EditEventAdd value)? add,
    TResult Function(AddEventFetch value)? addFetch,
    TResult Function(EditEventFetch value)? fetch,
    required TResult orElse(),
  }) {
    if (fetch != null) {
      return fetch(this);
    }
    return orElse();
  }
}

abstract class EditEventFetch implements EditEvent {
  factory EditEventFetch(
      {required final String id,
      required final String name,
      required final String measurement_units,
      required final String code,
      required final String description,
      required final String token}) = _$EditEventFetchImpl;

  String get id;
  String get name;
  String get measurement_units;
  String get code;
  String get description;
  String get token;
  @JsonKey(ignore: true)
  _$$EditEventFetchImplCopyWith<_$EditEventFetchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

WarehouseState _$WarehouseStateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'loading':
      return WarehouseStateLoading.fromJson(json);
    case 'loaded':
      return WarehouseStateLoaded.fromJson(json);
    case 'error':
      return WarehouseStateError.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'WarehouseState',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$WarehouseState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(WarehouseItem warehouseItemLoaded) loaded,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult? Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarehouseStateLoading value) loading,
    required TResult Function(WarehouseStateLoaded value) loaded,
    required TResult Function(WarehouseStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarehouseStateLoading value)? loading,
    TResult? Function(WarehouseStateLoaded value)? loaded,
    TResult? Function(WarehouseStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarehouseStateLoading value)? loading,
    TResult Function(WarehouseStateLoaded value)? loaded,
    TResult Function(WarehouseStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarehouseStateCopyWith<$Res> {
  factory $WarehouseStateCopyWith(
          WarehouseState value, $Res Function(WarehouseState) then) =
      _$WarehouseStateCopyWithImpl<$Res, WarehouseState>;
}

/// @nodoc
class _$WarehouseStateCopyWithImpl<$Res, $Val extends WarehouseState>
    implements $WarehouseStateCopyWith<$Res> {
  _$WarehouseStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WarehouseStateLoadingImplCopyWith<$Res> {
  factory _$$WarehouseStateLoadingImplCopyWith(
          _$WarehouseStateLoadingImpl value,
          $Res Function(_$WarehouseStateLoadingImpl) then) =
      __$$WarehouseStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WarehouseStateLoadingImplCopyWithImpl<$Res>
    extends _$WarehouseStateCopyWithImpl<$Res, _$WarehouseStateLoadingImpl>
    implements _$$WarehouseStateLoadingImplCopyWith<$Res> {
  __$$WarehouseStateLoadingImplCopyWithImpl(_$WarehouseStateLoadingImpl _value,
      $Res Function(_$WarehouseStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$WarehouseStateLoadingImpl implements WarehouseStateLoading {
  const _$WarehouseStateLoadingImpl({final String? $type})
      : $type = $type ?? 'loading';

  factory _$WarehouseStateLoadingImpl.fromJson(Map<String, dynamic> json) =>
      _$$WarehouseStateLoadingImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'WarehouseState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarehouseStateLoadingImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(WarehouseItem warehouseItemLoaded) loaded,
    required TResult Function() error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult? Function()? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarehouseStateLoading value) loading,
    required TResult Function(WarehouseStateLoaded value) loaded,
    required TResult Function(WarehouseStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarehouseStateLoading value)? loading,
    TResult? Function(WarehouseStateLoaded value)? loaded,
    TResult? Function(WarehouseStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarehouseStateLoading value)? loading,
    TResult Function(WarehouseStateLoaded value)? loaded,
    TResult Function(WarehouseStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$WarehouseStateLoadingImplToJson(
      this,
    );
  }
}

abstract class WarehouseStateLoading implements WarehouseState {
  const factory WarehouseStateLoading() = _$WarehouseStateLoadingImpl;

  factory WarehouseStateLoading.fromJson(Map<String, dynamic> json) =
      _$WarehouseStateLoadingImpl.fromJson;
}

/// @nodoc
abstract class _$$WarehouseStateLoadedImplCopyWith<$Res> {
  factory _$$WarehouseStateLoadedImplCopyWith(_$WarehouseStateLoadedImpl value,
          $Res Function(_$WarehouseStateLoadedImpl) then) =
      __$$WarehouseStateLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WarehouseItem warehouseItemLoaded});

  $WarehouseItemCopyWith<$Res> get warehouseItemLoaded;
}

/// @nodoc
class __$$WarehouseStateLoadedImplCopyWithImpl<$Res>
    extends _$WarehouseStateCopyWithImpl<$Res, _$WarehouseStateLoadedImpl>
    implements _$$WarehouseStateLoadedImplCopyWith<$Res> {
  __$$WarehouseStateLoadedImplCopyWithImpl(_$WarehouseStateLoadedImpl _value,
      $Res Function(_$WarehouseStateLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? warehouseItemLoaded = null,
  }) {
    return _then(_$WarehouseStateLoadedImpl(
      warehouseItemLoaded: null == warehouseItemLoaded
          ? _value.warehouseItemLoaded
          : warehouseItemLoaded // ignore: cast_nullable_to_non_nullable
              as WarehouseItem,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $WarehouseItemCopyWith<$Res> get warehouseItemLoaded {
    return $WarehouseItemCopyWith<$Res>(_value.warehouseItemLoaded, (value) {
      return _then(_value.copyWith(warehouseItemLoaded: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$WarehouseStateLoadedImpl implements WarehouseStateLoaded {
  const _$WarehouseStateLoadedImpl(
      {required this.warehouseItemLoaded, final String? $type})
      : $type = $type ?? 'loaded';

  factory _$WarehouseStateLoadedImpl.fromJson(Map<String, dynamic> json) =>
      _$$WarehouseStateLoadedImplFromJson(json);

  @override
  final WarehouseItem warehouseItemLoaded;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'WarehouseState.loaded(warehouseItemLoaded: $warehouseItemLoaded)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarehouseStateLoadedImpl &&
            (identical(other.warehouseItemLoaded, warehouseItemLoaded) ||
                other.warehouseItemLoaded == warehouseItemLoaded));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, warehouseItemLoaded);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WarehouseStateLoadedImplCopyWith<_$WarehouseStateLoadedImpl>
      get copyWith =>
          __$$WarehouseStateLoadedImplCopyWithImpl<_$WarehouseStateLoadedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(WarehouseItem warehouseItemLoaded) loaded,
    required TResult Function() error,
  }) {
    return loaded(warehouseItemLoaded);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult? Function()? error,
  }) {
    return loaded?.call(warehouseItemLoaded);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(warehouseItemLoaded);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarehouseStateLoading value) loading,
    required TResult Function(WarehouseStateLoaded value) loaded,
    required TResult Function(WarehouseStateError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarehouseStateLoading value)? loading,
    TResult? Function(WarehouseStateLoaded value)? loaded,
    TResult? Function(WarehouseStateError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarehouseStateLoading value)? loading,
    TResult Function(WarehouseStateLoaded value)? loaded,
    TResult Function(WarehouseStateError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$WarehouseStateLoadedImplToJson(
      this,
    );
  }
}

abstract class WarehouseStateLoaded implements WarehouseState {
  const factory WarehouseStateLoaded(
          {required final WarehouseItem warehouseItemLoaded}) =
      _$WarehouseStateLoadedImpl;

  factory WarehouseStateLoaded.fromJson(Map<String, dynamic> json) =
      _$WarehouseStateLoadedImpl.fromJson;

  WarehouseItem get warehouseItemLoaded;
  @JsonKey(ignore: true)
  _$$WarehouseStateLoadedImplCopyWith<_$WarehouseStateLoadedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WarehouseStateErrorImplCopyWith<$Res> {
  factory _$$WarehouseStateErrorImplCopyWith(_$WarehouseStateErrorImpl value,
          $Res Function(_$WarehouseStateErrorImpl) then) =
      __$$WarehouseStateErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WarehouseStateErrorImplCopyWithImpl<$Res>
    extends _$WarehouseStateCopyWithImpl<$Res, _$WarehouseStateErrorImpl>
    implements _$$WarehouseStateErrorImplCopyWith<$Res> {
  __$$WarehouseStateErrorImplCopyWithImpl(_$WarehouseStateErrorImpl _value,
      $Res Function(_$WarehouseStateErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$WarehouseStateErrorImpl implements WarehouseStateError {
  const _$WarehouseStateErrorImpl({final String? $type})
      : $type = $type ?? 'error';

  factory _$WarehouseStateErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$WarehouseStateErrorImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'WarehouseState.error()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarehouseStateErrorImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(WarehouseItem warehouseItemLoaded) loaded,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult? Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(WarehouseItem warehouseItemLoaded)? loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarehouseStateLoading value) loading,
    required TResult Function(WarehouseStateLoaded value) loaded,
    required TResult Function(WarehouseStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarehouseStateLoading value)? loading,
    TResult? Function(WarehouseStateLoaded value)? loaded,
    TResult? Function(WarehouseStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarehouseStateLoading value)? loading,
    TResult Function(WarehouseStateLoaded value)? loaded,
    TResult Function(WarehouseStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$WarehouseStateErrorImplToJson(
      this,
    );
  }
}

abstract class WarehouseStateError implements WarehouseState {
  const factory WarehouseStateError() = _$WarehouseStateErrorImpl;

  factory WarehouseStateError.fromJson(Map<String, dynamic> json) =
      _$WarehouseStateErrorImpl.fromJson;
}

EditState _$EditStateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'waiting':
      return EditStateWaiting.fromJson(json);
    case 'edit':
      return EditStateEdit.fromJson(json);
    case 'add':
      return EditStateAdd.fromJson(json);
    case 'saved':
      return EditStateSaved.fromJson(json);
    case 'error':
      return EditStateError.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EditState',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EditState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() waiting,
    required TResult Function(Item item) edit,
    required TResult Function() add,
    required TResult Function() saved,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? waiting,
    TResult? Function(Item item)? edit,
    TResult? Function()? add,
    TResult? Function()? saved,
    TResult? Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? waiting,
    TResult Function(Item item)? edit,
    TResult Function()? add,
    TResult Function()? saved,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditStateWaiting value) waiting,
    required TResult Function(EditStateEdit value) edit,
    required TResult Function(EditStateAdd value) add,
    required TResult Function(EditStateSaved value) saved,
    required TResult Function(EditStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditStateWaiting value)? waiting,
    TResult? Function(EditStateEdit value)? edit,
    TResult? Function(EditStateAdd value)? add,
    TResult? Function(EditStateSaved value)? saved,
    TResult? Function(EditStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditStateWaiting value)? waiting,
    TResult Function(EditStateEdit value)? edit,
    TResult Function(EditStateAdd value)? add,
    TResult Function(EditStateSaved value)? saved,
    TResult Function(EditStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditStateCopyWith<$Res> {
  factory $EditStateCopyWith(EditState value, $Res Function(EditState) then) =
      _$EditStateCopyWithImpl<$Res, EditState>;
}

/// @nodoc
class _$EditStateCopyWithImpl<$Res, $Val extends EditState>
    implements $EditStateCopyWith<$Res> {
  _$EditStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EditStateWaitingImplCopyWith<$Res> {
  factory _$$EditStateWaitingImplCopyWith(_$EditStateWaitingImpl value,
          $Res Function(_$EditStateWaitingImpl) then) =
      __$$EditStateWaitingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EditStateWaitingImplCopyWithImpl<$Res>
    extends _$EditStateCopyWithImpl<$Res, _$EditStateWaitingImpl>
    implements _$$EditStateWaitingImplCopyWith<$Res> {
  __$$EditStateWaitingImplCopyWithImpl(_$EditStateWaitingImpl _value,
      $Res Function(_$EditStateWaitingImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$EditStateWaitingImpl implements EditStateWaiting {
  const _$EditStateWaitingImpl({final String? $type})
      : $type = $type ?? 'waiting';

  factory _$EditStateWaitingImpl.fromJson(Map<String, dynamic> json) =>
      _$$EditStateWaitingImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EditState.waiting()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditStateWaitingImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() waiting,
    required TResult Function(Item item) edit,
    required TResult Function() add,
    required TResult Function() saved,
    required TResult Function() error,
  }) {
    return waiting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? waiting,
    TResult? Function(Item item)? edit,
    TResult? Function()? add,
    TResult? Function()? saved,
    TResult? Function()? error,
  }) {
    return waiting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? waiting,
    TResult Function(Item item)? edit,
    TResult Function()? add,
    TResult Function()? saved,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditStateWaiting value) waiting,
    required TResult Function(EditStateEdit value) edit,
    required TResult Function(EditStateAdd value) add,
    required TResult Function(EditStateSaved value) saved,
    required TResult Function(EditStateError value) error,
  }) {
    return waiting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditStateWaiting value)? waiting,
    TResult? Function(EditStateEdit value)? edit,
    TResult? Function(EditStateAdd value)? add,
    TResult? Function(EditStateSaved value)? saved,
    TResult? Function(EditStateError value)? error,
  }) {
    return waiting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditStateWaiting value)? waiting,
    TResult Function(EditStateEdit value)? edit,
    TResult Function(EditStateAdd value)? add,
    TResult Function(EditStateSaved value)? saved,
    TResult Function(EditStateError value)? error,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EditStateWaitingImplToJson(
      this,
    );
  }
}

abstract class EditStateWaiting implements EditState {
  const factory EditStateWaiting() = _$EditStateWaitingImpl;

  factory EditStateWaiting.fromJson(Map<String, dynamic> json) =
      _$EditStateWaitingImpl.fromJson;
}

/// @nodoc
abstract class _$$EditStateEditImplCopyWith<$Res> {
  factory _$$EditStateEditImplCopyWith(
          _$EditStateEditImpl value, $Res Function(_$EditStateEditImpl) then) =
      __$$EditStateEditImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Item item});

  $ItemCopyWith<$Res> get item;
}

/// @nodoc
class __$$EditStateEditImplCopyWithImpl<$Res>
    extends _$EditStateCopyWithImpl<$Res, _$EditStateEditImpl>
    implements _$$EditStateEditImplCopyWith<$Res> {
  __$$EditStateEditImplCopyWithImpl(
      _$EditStateEditImpl _value, $Res Function(_$EditStateEditImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
  }) {
    return _then(_$EditStateEditImpl(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as Item,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ItemCopyWith<$Res> get item {
    return $ItemCopyWith<$Res>(_value.item, (value) {
      return _then(_value.copyWith(item: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$EditStateEditImpl implements EditStateEdit {
  const _$EditStateEditImpl({required this.item, final String? $type})
      : $type = $type ?? 'edit';

  factory _$EditStateEditImpl.fromJson(Map<String, dynamic> json) =>
      _$$EditStateEditImplFromJson(json);

  @override
  final Item item;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EditState.edit(item: $item)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditStateEditImpl &&
            (identical(other.item, item) || other.item == item));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, item);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EditStateEditImplCopyWith<_$EditStateEditImpl> get copyWith =>
      __$$EditStateEditImplCopyWithImpl<_$EditStateEditImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() waiting,
    required TResult Function(Item item) edit,
    required TResult Function() add,
    required TResult Function() saved,
    required TResult Function() error,
  }) {
    return edit(item);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? waiting,
    TResult? Function(Item item)? edit,
    TResult? Function()? add,
    TResult? Function()? saved,
    TResult? Function()? error,
  }) {
    return edit?.call(item);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? waiting,
    TResult Function(Item item)? edit,
    TResult Function()? add,
    TResult Function()? saved,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (edit != null) {
      return edit(item);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditStateWaiting value) waiting,
    required TResult Function(EditStateEdit value) edit,
    required TResult Function(EditStateAdd value) add,
    required TResult Function(EditStateSaved value) saved,
    required TResult Function(EditStateError value) error,
  }) {
    return edit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditStateWaiting value)? waiting,
    TResult? Function(EditStateEdit value)? edit,
    TResult? Function(EditStateAdd value)? add,
    TResult? Function(EditStateSaved value)? saved,
    TResult? Function(EditStateError value)? error,
  }) {
    return edit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditStateWaiting value)? waiting,
    TResult Function(EditStateEdit value)? edit,
    TResult Function(EditStateAdd value)? add,
    TResult Function(EditStateSaved value)? saved,
    TResult Function(EditStateError value)? error,
    required TResult orElse(),
  }) {
    if (edit != null) {
      return edit(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EditStateEditImplToJson(
      this,
    );
  }
}

abstract class EditStateEdit implements EditState {
  const factory EditStateEdit({required final Item item}) = _$EditStateEditImpl;

  factory EditStateEdit.fromJson(Map<String, dynamic> json) =
      _$EditStateEditImpl.fromJson;

  Item get item;
  @JsonKey(ignore: true)
  _$$EditStateEditImplCopyWith<_$EditStateEditImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditStateAddImplCopyWith<$Res> {
  factory _$$EditStateAddImplCopyWith(
          _$EditStateAddImpl value, $Res Function(_$EditStateAddImpl) then) =
      __$$EditStateAddImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EditStateAddImplCopyWithImpl<$Res>
    extends _$EditStateCopyWithImpl<$Res, _$EditStateAddImpl>
    implements _$$EditStateAddImplCopyWith<$Res> {
  __$$EditStateAddImplCopyWithImpl(
      _$EditStateAddImpl _value, $Res Function(_$EditStateAddImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$EditStateAddImpl implements EditStateAdd {
  const _$EditStateAddImpl({final String? $type}) : $type = $type ?? 'add';

  factory _$EditStateAddImpl.fromJson(Map<String, dynamic> json) =>
      _$$EditStateAddImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EditState.add()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditStateAddImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() waiting,
    required TResult Function(Item item) edit,
    required TResult Function() add,
    required TResult Function() saved,
    required TResult Function() error,
  }) {
    return add();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? waiting,
    TResult? Function(Item item)? edit,
    TResult? Function()? add,
    TResult? Function()? saved,
    TResult? Function()? error,
  }) {
    return add?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? waiting,
    TResult Function(Item item)? edit,
    TResult Function()? add,
    TResult Function()? saved,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditStateWaiting value) waiting,
    required TResult Function(EditStateEdit value) edit,
    required TResult Function(EditStateAdd value) add,
    required TResult Function(EditStateSaved value) saved,
    required TResult Function(EditStateError value) error,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditStateWaiting value)? waiting,
    TResult? Function(EditStateEdit value)? edit,
    TResult? Function(EditStateAdd value)? add,
    TResult? Function(EditStateSaved value)? saved,
    TResult? Function(EditStateError value)? error,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditStateWaiting value)? waiting,
    TResult Function(EditStateEdit value)? edit,
    TResult Function(EditStateAdd value)? add,
    TResult Function(EditStateSaved value)? saved,
    TResult Function(EditStateError value)? error,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EditStateAddImplToJson(
      this,
    );
  }
}

abstract class EditStateAdd implements EditState {
  const factory EditStateAdd() = _$EditStateAddImpl;

  factory EditStateAdd.fromJson(Map<String, dynamic> json) =
      _$EditStateAddImpl.fromJson;
}

/// @nodoc
abstract class _$$EditStateSavedImplCopyWith<$Res> {
  factory _$$EditStateSavedImplCopyWith(_$EditStateSavedImpl value,
          $Res Function(_$EditStateSavedImpl) then) =
      __$$EditStateSavedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EditStateSavedImplCopyWithImpl<$Res>
    extends _$EditStateCopyWithImpl<$Res, _$EditStateSavedImpl>
    implements _$$EditStateSavedImplCopyWith<$Res> {
  __$$EditStateSavedImplCopyWithImpl(
      _$EditStateSavedImpl _value, $Res Function(_$EditStateSavedImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$EditStateSavedImpl implements EditStateSaved {
  const _$EditStateSavedImpl({final String? $type}) : $type = $type ?? 'saved';

  factory _$EditStateSavedImpl.fromJson(Map<String, dynamic> json) =>
      _$$EditStateSavedImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EditState.saved()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditStateSavedImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() waiting,
    required TResult Function(Item item) edit,
    required TResult Function() add,
    required TResult Function() saved,
    required TResult Function() error,
  }) {
    return saved();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? waiting,
    TResult? Function(Item item)? edit,
    TResult? Function()? add,
    TResult? Function()? saved,
    TResult? Function()? error,
  }) {
    return saved?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? waiting,
    TResult Function(Item item)? edit,
    TResult Function()? add,
    TResult Function()? saved,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditStateWaiting value) waiting,
    required TResult Function(EditStateEdit value) edit,
    required TResult Function(EditStateAdd value) add,
    required TResult Function(EditStateSaved value) saved,
    required TResult Function(EditStateError value) error,
  }) {
    return saved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditStateWaiting value)? waiting,
    TResult? Function(EditStateEdit value)? edit,
    TResult? Function(EditStateAdd value)? add,
    TResult? Function(EditStateSaved value)? saved,
    TResult? Function(EditStateError value)? error,
  }) {
    return saved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditStateWaiting value)? waiting,
    TResult Function(EditStateEdit value)? edit,
    TResult Function(EditStateAdd value)? add,
    TResult Function(EditStateSaved value)? saved,
    TResult Function(EditStateError value)? error,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EditStateSavedImplToJson(
      this,
    );
  }
}

abstract class EditStateSaved implements EditState {
  const factory EditStateSaved() = _$EditStateSavedImpl;

  factory EditStateSaved.fromJson(Map<String, dynamic> json) =
      _$EditStateSavedImpl.fromJson;
}

/// @nodoc
abstract class _$$EditStateErrorImplCopyWith<$Res> {
  factory _$$EditStateErrorImplCopyWith(_$EditStateErrorImpl value,
          $Res Function(_$EditStateErrorImpl) then) =
      __$$EditStateErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EditStateErrorImplCopyWithImpl<$Res>
    extends _$EditStateCopyWithImpl<$Res, _$EditStateErrorImpl>
    implements _$$EditStateErrorImplCopyWith<$Res> {
  __$$EditStateErrorImplCopyWithImpl(
      _$EditStateErrorImpl _value, $Res Function(_$EditStateErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$EditStateErrorImpl implements EditStateError {
  const _$EditStateErrorImpl({final String? $type}) : $type = $type ?? 'error';

  factory _$EditStateErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$EditStateErrorImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EditState.error()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditStateErrorImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() waiting,
    required TResult Function(Item item) edit,
    required TResult Function() add,
    required TResult Function() saved,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? waiting,
    TResult? Function(Item item)? edit,
    TResult? Function()? add,
    TResult? Function()? saved,
    TResult? Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? waiting,
    TResult Function(Item item)? edit,
    TResult Function()? add,
    TResult Function()? saved,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditStateWaiting value) waiting,
    required TResult Function(EditStateEdit value) edit,
    required TResult Function(EditStateAdd value) add,
    required TResult Function(EditStateSaved value) saved,
    required TResult Function(EditStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EditStateWaiting value)? waiting,
    TResult? Function(EditStateEdit value)? edit,
    TResult? Function(EditStateAdd value)? add,
    TResult? Function(EditStateSaved value)? saved,
    TResult? Function(EditStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditStateWaiting value)? waiting,
    TResult Function(EditStateEdit value)? edit,
    TResult Function(EditStateAdd value)? add,
    TResult Function(EditStateSaved value)? saved,
    TResult Function(EditStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EditStateErrorImplToJson(
      this,
    );
  }
}

abstract class EditStateError implements EditState {
  const factory EditStateError() = _$EditStateErrorImpl;

  factory EditStateError.fromJson(Map<String, dynamic> json) =
      _$EditStateErrorImpl.fromJson;
}
